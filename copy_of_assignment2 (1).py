# -*- coding: utf-8 -*-
"""Copy of Assignment2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1JO9SZ4UiRPLqxiSmstjSES4D9fwD7q4Y
"""

from google.colab import files
uploaded = files.upload()

# Dataset is now stored in a Pandas Dataframe
import io
import pandas as pd
data_frame = pd.read_csv(io.BytesIO(uploaded['datasets_13996_18858_WA_Fn-UseC_-Telco-Customer-Churn.csv']))

data_frame

dataf = data_frame.loc[:,['gender','SeniorCitizen','Partner','Dependents','tenure','PhoneService','PaperlessBilling','MonthlyCharges','Churn','MultipleLines','InternetService','OnlineSecurity','OnlineBackup','DeviceProtection','TechSupport','StreamingTV','StreamingMovies','Contract', 'PaymentMethod']]

dataf

dataf.isna().sum()

# data_frame.drop(columns='customerID')

from numpy import array
from sklearn.preprocessing import LabelEncoder
label_encoder = LabelEncoder()
features_le = ['gender','Partner','Dependents','PhoneService','PaperlessBilling']
def label_encoding(features,dataf):
  for u in features :
    dataf[u]=dataf[u].map({'Yes':1,'No':0})
    return

label_encoding(['Partner','Dependents','PhoneService','PaperlessBilling'],dataf)
dataf['gender']=dataf['gender'].map({'Female':1, 'Male':0})
dataf['Dependents']=dataf['Dependents'].map({'Yes':1,'No':0})
dataf['PhoneService']=dataf['PhoneService'].map({'Yes':1,'No':0})
dataf['PaperlessBilling']=dataf['PaperlessBilling'].map({'Yes':1,'No':0})
dataf['Churn']=dataf['Churn'].map({'Yes':1, 'No':0})

dataf

features_ohe = ['MultipleLines','InternetService','OnlineSecurity','OnlineBackup','DeviceProtection','TechSupport','StreamingTV','StreamingMovies','Contract','PaymentMethod']
dataf = pd.get_dummies(dataf, columns=features_ohe)

dataf

from matplotlib import pyplot as plt
import seaborn as sns
plt.figure(figsize=(16,10))
plots = {1:[111], 2:[121,122], 3:[131,132,133], 4:[221,222,223,224],5: [231,232,233,234,235],6:[231,232,233,234,235,236]}
def boxplot(x,y,df):
  rows = int(str(plots[len(y)][0])[0])
  columns= int(str(plots[len(y)][0])[1])
  plt.figure(figsize=(5*columns,5*rows))

  for i,j in enumerate(y):
    plt.subplot(plots[len(y)][i])
    ax = sns.boxplot(x=x,y=j,data=dataf[[x,j]])
    ax.set_title(j)
    return plt.show()


boxplot("Churn",['tenure'],dataf)
boxplot("Churn",['MonthlyCharges'],dataf)

def countplot(x,y,df):
  rows = int(str(plots[len(y)][0])[0])
  columns= int(str(plots[len(y)][0])[1])
  
  plt.figure(figsize=(5*columns,5*rows))

  for i,j in enumerate(y):
    plt.subplot(plots[len(y)][i])
    ax = sns.countplot(x=j,hue=x,data=dataf,alpha=0.8, linewidth=1, edgecolor='black')
    ax.set_title(j)
    return plt.show()
countplot("Churn",['SeniorCitizen'], dataf)
countplot("Churn",['Contract_Month-to-month'], dataf)
countplot("Churn",['Contract_One year'], dataf)
countplot("Churn",['Contract_Two year'], dataf)
countplot("Churn",['Partner'], dataf)
countplot("Churn",['Dependents'], dataf)
countplot("Churn",['PaymentMethod_Bank transfer (automatic)'], data_frame)
countplot("Churn",['PaymentMethod_Credit card (automatic)'], data_frame)
countplot("Churn",['PaymentMethod_Electronic check'], data_frame)
countplot("Churn",['PaymentMethod_Mailed check'], data_frame)
countplot("Churn",['InternetService_DSL'], data_frame)
countplot("Churn",['InternetService_Fiber optic'], data_frame)
countplot("Churn",['InternetService_No'], data_frame)

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import xgboost as xgb

from sklearn.model_selection import train_test_split
# Create arrays for the features and the target: X, y
X, y = dataf.iloc[:, :-1], dataf.iloc[:, -1]
# Create the training and test sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=123)
# Instantiate the XGBClassifier: xg_cl
xg_cl = xgb.XGBClassifier(objective='binary:logistic', n_estimators=10, seed=123)

# Fit the classifier to the training set
xg_cl.fit(X_train, y_train)

# Predict the labels of the test set: preds
preds = xg_cl.predict(X_test)
# Compute the accuracy: accuracy
accuracy = float(np.sum(preds == y_test)) / y_test.shape[0]
print("accuracy: %f" % (accuracy))

# Create the DMatrix from X and y: datafmatrix
datafmatrix = xgb.DMatrix(data=X, label=y)

# Create the parameter dictionary: params
params = {'objective':"reg:logistic", "max_depth":5}

# Perform cross-validation: cv_results
cv_results = xgb.cv(dtrain=datafmatrix, params=params,
                   nfold=3, num_boost_round=5,
                   metrics="error", as_pandas=True, seed=123)

# Pint cv_results
print(cv_results)

# Print the accuracy
print(((1 - cv_results['test-error-mean']).iloc[-1]))

# Perform cross_validation: cv_results
cv_results = xgb.cv(dtrain=datafmatrix, params=params,
                    nfold=3, num_boost_round=5,
                    metrics="auc", as_pandas=True, seed=123)

# Print cv_results
print(cv_results)

# Print the AUC
print((cv_results["test-auc-mean"]).iloc[-1])

